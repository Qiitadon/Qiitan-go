# enumerable

`enumerable` とは「数え上げができるもの」全般を指します。特定の型名ではありません。

基本的に `enumerable` は `iterable` と同義です。`enumerable` は「カウント（数え上げ）処理」に使える値に使われるのに対し、`iterable` は「繰り返し処理」ができる値に使われます。

逆に言えば、`enumerable` な値でないとイテレーション（反復処理）ができないとも言えます。

# iterable

`iterable` は配列全般のことで「反復処理が可能な型」の総称です。特定の型名ではありません。他言語で言う `for` や `foreach` などでループ処理できる値を指します。

具体的には、以下の配列を指します。

- `array`: 連想配列の型
- `map`: 添字配列の型
- `immutable array`: 定数化された連想配列の型
- `immutable map`: 定数化された添字配列の型

内部的には、以下の条件式で `true` が返された場合に「`iterable` である」と判断しています。

```go
is_enumerable := func(x) {
  return is_array(x) || is_map(x) || is_immutable_array(x) || is_immutable_map(x)
}
```

# mutable/immutable

SF で言う、突然変異のミュータント（`mutant`）のように、「`mutable`」は「状態を変異できる型」を言います。そして `immutable` は「状態が変異しない型」を指します。

キーたん語では**基本的に、すべての型は `immutable`（状態変更ができない型）です**。唯一、`mutable` （変更できる型）なのは `array`（連想配列）型と `map`（添字配列）型のみです。

オブジェクトが生成されると変数に代入されます。変数の中身（オブジェクト）を入れ替えることはできても、中身そのもの状態（オブジェクトの値）を直接変えることはできません。

そのため、**状態を変異させたい場合は、変異した状態にしたものを変数に代入する**ことを基本としています。

注意点として「変数」は「オブジェクトの入れ物」として特化しています。つまり、変数自体は型を持たず、現在代入されているオブジェクトの型が、その変数の型となります。

```go
// 変数 a を ":=" で生成。
// 中身に string 型で値が "abc" の `immutable` なオブジェクトを代入。
a := "abc"

// `immutable` なオブジェクトを変更しようとしているのでエラーになります。
a[1] = "d" // --> error

// 変数 a に、新たな string 型のオブジェクトを代入。
a = a + "def"
// a --> abcdef

// 逆に、変数 a 自体は入れ物なので別の型のオブジェクトを入れても問題ない。
a = 1234
// a --> 1234
```


