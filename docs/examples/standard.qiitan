/*
    Qiitan スクリプトの基本構文
*/

// ----------------------------------------------------------------------------
// 標準モジュールの利用（同梱されているパッケージの利用）
//
// モジュールとは関数群をパッケージにしたもので、変数に代入して呼び出します。
// fmt は Print 系の出力用関数が入ったパッケージで、"print"（改行なし）"println"
// （改行付き print）などの関数を持っています。
fmt := import("fmt")
fmt.println("Hello world! I'm Qiitan!!") // --> Hello world! I'm Qiitan!!

// ----------------------------------------------------------------------------
// 変数の宣言と基本データ型
a := "foo"   // string
b := -19.84  // floating point
c := 5       // integer
d := true    // boolean
e := '九'    // char （Go の rune と同等）

fmt.println("a: ", a) // --> a: foo
fmt.println("b: ", b) // --> b: -19.84
fmt.println("c: ", c) // --> c: 5
fmt.println("d: ", d) // --> d: true
fmt.println("e: ", e) // --> e: 九

// ----------------------------------------------------------------------------
// 再代入（再割り当て）
b = "bar"    // 一度宣言されていれば型違いでも代入可能
fmt.println("f: ", b) // --> f: bar

// ----------------------------------------------------------------------------
// 配列（添字配列と連想配列）
m := {a: {b: {c: [1, 2, 3]}}}
fmt.println("g: ", m) // --> g: {a: {b: {c: [1, 2, 3]}}}

// ----------------------------------------------------------------------------
// 文字列のバイナリ単位ごとのスライス
str := "hello world"
fmt.println(str[1:5]) // --> "ello"

// ----------------------------------------------------------------------------
// 連想配列の要素ごとのスライス
arr := [1, 2, 3, 4, 5]
fmt.println(arr[2:4]) // --> [3, 4]

// ----------------------------------------------------------------------------
// 型変換
s1 := string(1984)  // "1984"
i2 := int("-999")   // -999
f3 := float(-51)    // -51.0
b4 := bool(1)       // true
c5 := char(88)      // 'X'

// ----------------------------------------------------------------------------
// if 文
one := 1
if one < 3 {
    fmt.println("one is smaller than 3")
} else {
    fmt.println("one is greater than 3")
} // ---> one is smaller than 3

// ----------------------------------------------------------------------------
// if 文（変数の宣言と同時）
if three := 3; three > 2 {  // three はこの if 文のスコープ内でしか使えなくなる
    fmt.println("three > 2")
} else if three == 2 {
    fmt.println("three = 2")
} else {
    fmt.println("three < 2")
}
// fmt.println(three) --> スコープ外の参照になりコンパイルエラー

// ----------------------------------------------------------------------------
// ユーザ関数の定義（関数は変数に無名関数を代入して使う）
sayHello := func() {
    fmt.println("hello!")
}
sayHello() // --> hello!

// ----------------------------------------------------------------------------
// ユーザ関数の利用（引数付き）
each := func(seq, fn) {
    // 配列のループ
    for x in seq {
        fn(x)
    }
}

sum := func(seq) {
   s := 0 // s の宣言

   each(seq, func(x) {
       s += x // += は複合演算子（加算演算子 + と代入演算子 = の複合）
   })

   return s
}
fmt.println("sum: ", sum([1, 2, 3])) // --> sum: 6

// ----------------------------------------------------------------------------
// 添字配列（マップ）から連想配列へ割り当て
map_to_array := func(m) {
    arr := [] // arr の宣言

    // m のループ
    for key, value in m {
        arr = append(arr, key, value)  // 'append' は標準関数
    }

    return arr
}

m_arr := map_to_array(m)
fmt.println(m_arr, " (len: ", len(m_arr), ")") // --> ["a", {b: {c: [1, 2, 3]}}] (len: 2)

// ----------------------------------------------------------------------------
// 末尾再帰（tail-call optimization）による再起処理の高速化（末尾呼出し最適化）。
count_odds := func(n, c) {
	if n == 0 {
		return c
	}

    if n % 2 == 1 {
	    c++
	}

	return count_odds(n-1, c)
}
num_odds := count_odds(100000, 0)
fmt.println(num_odds) // --> 50000

// ----------------------------------------------------------------------------
// for ループ
seven := 0
arr2 := [1, 2, 3, 1]
for i:=0; i<len(arr2); i++ {
    seven += arr2[i]
}
fmt.println("seven: ", seven) // --> seven: 7
